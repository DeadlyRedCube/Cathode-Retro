<!DOCTYPE html>
<html>
  <head>
    <title>Cathode Retro Docs</title>
    <link href="../../docs.css" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" charset="UTF-8">
    <script src="../../main-scripts.js"></script>
  </head>
  <body onload="OnLoad()" class="page">
    <header class="header"><button id="sidebar-button"></button></header>
    <div id="sidebar-container" class="sidebar-container"><iframe class="sidebar-frame" src="../../sidebar.html?page=cpp-reference-classes-internal-rgbtocrt"></iframe></div>
    <div id="content-outer" class="content-outer">
      <main>
        <h1>CathodeRetro::<wbr>Internal::<wbr>RGBToCRT</h1>
        <div>
          <p>
            This is an internal class used by <code><a href="cathoderetro.html">CathodeRetro::<wbr>CathodeRetro</a></code>
            to take an RGB image and draw it to a render target to look like it is on a CRT TV.
          </p>
          <p>
            If you are using the <code><a href="cathoderetro.html">CathodeRetro::<wbr>CathodeRetro</a></code>
            class, you should not need to use this class directly.
          </p>
          <ul>
            <li><a href="#public">Go to Public Members</a></li>
            <li><a href="#private">Go to Private Members</a></li>
          </ul>
        </div>          
        <h2 id="public">Public Members</h2>
        <div class="index">
          <h4>Public Methods</h4>
          <nav>
            <menu>
              <li><a href="#constructor">(constructor)</a></li>
              <li><a href="#SetSettings">SetSettings</a></li>
              <li><a href="#SetOutputSize">SetOutputSize</a></li>
              <li><a href="#Render">Render</a></li>
            </menu>
          </nav>
        </div>

        <h3>Public Methods</h3>
        <dl class="member-list">
          <dt id="constructor">(constructor)</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                RGBToCRT(
                  IGraphicsDevice *deviceIn,
                  uint32_t originalInputImageWidthIn,
                  uint32_t processedRGBTextureWidthIn,
                  uint32_t scanlineCountIn,
                  float pixelAspectIn)
              </pre>
            </div>
            <h5>Description</h5>
            <section>
              Construct a new instance of the <code>Internal::<wbr>RGBToCRT</code> class.
            </section>
            <h5>Parameters</h5>
            <section>
              <dl>
                <dt><code>deviceIn</code></dt>
                <dd>
                  <p>Type: <code><a href="../interfaces/igraphicsdevice.html">IGraphicsDevice</a> *</code></p>
                  <p>
                    Pointer to the graphics device instance that this instance should use for all of its drawing-related functionality.
                    This pointer will be cached so the lifetime of <code>deviceIn</code> must extend past the lifetime of the
                    <code>Internal::<wbr>RGBToCRT</code> instance being created.
                  </p>
                </dd>
                <dt><code>originalInputImageWidthIn</code></dt>
                <dd>
                  <p>Type: <code>uint32_t</code></p>
                  <p>
                    The width of the original input image (the one passed to <code><a href="cathoderetro.html#Render">CathodeRetro::<wbr>Render</a></code>),
                    before running through the generator and decoder.
                  </p>
                </dd>
                <dt><code>processedRGBTextureWidthIn</code></dt>
                <dd>
                  <p>Type: <code>uint32_t</code></p>
                  <p>
                    The width of the input texture that <code><a href="#Render">Render</a></code> will be provided.
                  </p>
                </dd>
                <dt><code>scanlineCountIn</code></dt>
                <dd>
                  <p>Type: <code>uint32_t</code></p>
                  <p>
                    The height of the input texture that <code><a href="#Render">Render</a></code> will be provided.
                  </p>
                </dd>
                <dt><code>pixelAspectIn</code></dt>
                <dd>
                  <p>Type: <code>float</code></p>
                  <p>
                    The pixel aspect ratio of the input signal (relative to the original input). This value comes from
                    the <code><a href="../structs/signalproperties.html">SignalProperties</a></code> given to the <code><a href="cathoderetro.html">CathodeRetro</a></code>
                    class.
                  </p>
                </dd>
              </dl>
            </section>
          </dd>

          <dt id="SetSettings">SetSettings</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                void SetSettings(
                  const OverscanSettings &amp;overscan, 
                  const ScreenSettings &amp;screen)
              </pre>
            </div>
            <h5>Description</h5>
            <section>
              Set the settings that describe how the screen should appear.
            </section>
            <h5>Parameters</h5>
            <section>
              <dl>
                <dt><code>overscan</code></dt>
                <dd>
                  <p>Type: <code>const <a href="../structs/overscansettings.html">OverscanSettings</a> &amp;</code></p>
                  <p>
                    A description of how much the various edges of the input image are cut off by the "bevel" of the TV.
                  </p>
                </dd>

                <dt><code>screen</code></dt>
                <dd>
                  <p>Type: <code>const <a href="../structs/screensettings.html">ScreenSettings</a> &amp;</code></p>
                  <p>
                    Information about the properties of the screen itself.
                  </p>
                </dd>
              </dl>
            </section>
          </dd>

          <dt id="SetOutputSize">SetOutputSize</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                void SetOutputSize(
                  uint32_t outputWidth,
                  uint32_t outputHeight)
              </pre>
            </div>
            <h5>Description</h5>
            <section>
              <p>
                Set the size of the final output render target that 
                <code><a href="cathoderetro.html#Render">CathodeRetro::<wbr>Render</a></code>
                will be given.
              </p>
              <p>
                If the width or height change from what they were before, this will reallocate a render target.
              </p>
            </section>
            <h5>Parameters</h5>
            <section>
              <dl>
                <dt><code>outputWidth</code></dt>
                <dd>
                  <p>Type: <code>uint32_t</code></p>
                  <p>
                    The expected width of the final output render target that <code><a href="cathoderetro.html#Render">CathodeRetro::<wbr>Render</a></code>
                    will be given.
                  </p>
                </dd>

                <dt><code>outputHeight</code></dt>
                <dd>
                  <p>Type: <code>uint32_t</code></p>
                  <p>
                    The expected height of the final output render target that <code><a href="cathoderetro.html#Render">CathodeRetro::<wbr>Render</a></code>
                    will be given.
                  </p>
                </dd>
              </dl>
            </section>
          </dd>

          <dt id="Render">Render</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                void Render(
                  const ITexture *currentFrameRGBInput,
                  IRenderTarget *outputTexture,
                  ScanlineType scanType)
              </pre>
            </div>
            <h5>Description</h5>
            <section>
              Render a CRT TV emulation pass using the input texture as what is on-screen.
            </section>
            <h5>Parameters</h5>
            <section>
              <dl>
                <dt><code>currentFrameRGBInput</code></dt>
                <dd>
                  <p>Type: <code>const <a href="../interfaces/itexture.html">ITexture</a> *</code></p>
                  <p>
                    The input RGB frame data, representing what is "on-screen."
                  </p>
                  <p>
                    Its dimensions are expected to match the <code>processedRGBTextureWidthIn</code> 
                    (width) and <code>scanlineCountIn</code> (height) values that were passed to the 
                    <a href="#constructor">constructor</a>.
                  </p>
                </dd>
                <dt><code>outputTexture</code></dt>
                <dd>
                  <p>Type: <code><a href="../interfaces/irendertarget.html">IRenderTarget</a> *</code></p>
                  <p>
                    The texture that the result of this rendering will be rendered to.
                  </p>
                  <p>
                    Its dimensions are expected to match the <code>outputWidth</code> and <code>outputHeight</code>
                    values passed to the most-recent call to <code><a href="#SetOutputSize">SetOutputSize</a></code>.
                  </p>
                </dd>
                <dt><code>scanType</code></dt>
                <dd>
                  <p>Type: <code><a href="../enums/scanlinetype.html">ScanlineType</a></code></p>
                  <p>
                    Which type of scanlines to render for this frame (even or odd).
                  </p>
                </dd>
              </dl>
            </section>
          </dd>
        </dl>


        <h2 id="private">Private Members</h3>
        <div class="index">
          <h4>Private Constants</h4>
          <nav>
            <menu>
              <li><a href="#k_maskSize">k_maskSize</a></li>
            </menu>
          </nav>
          <h4>Private Structures</h4>
          <nav>
            <menu>
              <li><a href="#AspectData">AspectData</a></li>
              <li><a href="#CommonConstants">CommonConstants</a></li>
              <li><a href="#ScreenTextureConstants">ScreenTextureConstants</a></li>
              <li><a href="#RGBToScreenConstants">RGBToScreenConstants</a></li>
              <li><a href="#GaussianBlurConstants">GaussianBlurConstants</a></li>
              <li><a href="#ToneMapConstants">ToneMapConstants</a></li>
            </menu>
          </nav>
          <h4>Private Methods</h4>
          <nav>
            <menu>
              <li><a href="#CalculateAspectData">CalculateAspectData</a></li>
              <li><a href="#CalculateCommonConstants">CalculateCommonConstants</a></li>
              <li><a href="#RenderScreenTexture">RenderScreenTexture</a></li>
              <li><a href="#UpdateBlurTextures">UpdateBlurTextures</a></li>
              <li><a href="#RenderMaskTexture">RenderMaskTexture</a></li>
              <li><a href="#RenderBlur">RenderBlur</a></li>
            </menu>
          </nav>
          <h4>Private Fields</h4>
          <nav>
            <menu>
              <li><a href="#device">device</a></li>
              <li>&nbsp;</li>
              <li><a href="#originalInputImageWidth">originalInputImageWidth</a></li>
              <li><a href="#processedRGBTextureWidth">processedRGBTextureWidth</a></li>
              <li><a href="#scanlineCount">scanlineCount</a></li>
              <li><a href="#pixelAspect">pixelAspect</a></li>
              <li><a href="#isFirstFrame">isFirstFrame</a></li>
              <li>&nbsp;</li>
              <li><a href="#screenTextureConstantBuffer">screenTextureConstantBuffer</a></li>
              <li><a href="#rgbToScreenConstantBuffer">rgbToScreenConstantBuffer</a></li>
              <li><a href="#toneMapConstantBuffer">toneMapConstantBuffer</a></li>
              <li><a href="#blurDownsampleConstantBuffer">blurDownsampleConstantBuffer</a></li>
              <li><a href="#gaussianBlurConstantBufferH">gaussianBlurConstantBufferH</a></li>
              <li><a href="#gaussianBlurConstantBufferV">gaussianBlurConstantBufferV</a></li>
              <li><a href="#generateMaskConstantBuffer">generateMaskConstantBuffer</a></li>
              <li><a href="#maskDownsampleConstantBufferH">maskDownsampleConstantBufferH</a></li>
              <li><a href="#maskDownsampleConstantBufferV">maskDownsampleConstantBufferV</a></li>
              <li>&nbsp;</li>
              <li><a href="#prevRGBInput">prevRGBInput</a></li>
              <li>&nbsp;</li>
              <li><a href="#maskTexture">maskTexture</a></li>
              <li><a href="#halfWidthMaskTexture">halfWidthMaskTexture</a></li>
              <li><a href="#screenTexture">screenTexture</a></li>
              <li>&nbsp;</li>
              <li><a href="#toneMapTexture">toneMapTexture</a></li>
              <li><a href="#blurScratchTexture">blurScratchTexture</a></li>
              <li><a href="#blurTexture">blurTexture</a></li>
              <li>&nbsp;</li>
              <li><a href="#screenSettings">screenSettings</a></li>
              <li><a href="#overscanSettings">overscanSettings</a></li>
              <li><a href="#needsRenderScreenTexture">needsRenderScreenTexture</a></li>
              <li><a href="#needsRenderMaskTexture">needsRenderMaskTexture</a></li>
              <li>&nbsp;</li>
              <li><a href="#prevScanlineType">prevScanlineType</a></li>
              <li><a href="#downsampleDirX">downsampleDirX</a></li>
              <li><a href="#downsampleDirY">downsampleDirY</a></li>
            </menu>
          </nav>
        </div>

        <h3>Private Constants</h3>
        <dl class="member-list">
          <dt id="k_maskSize">k_maskSize</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                static constexpr uint32_t k_maskSize = 512
              </pre>
            </div>
            <h5>Description</h5>
            <section>
              <p>
                The horizontal resolution of <code><a href="#maskTexture">maskTexture</a></code>, the 
                texture that the CRT mask is rendered to.
              </p>
              <p>
                The vertical resolution of the texture is half this value.
              </p>
              <p>
                Given the small scale of the mask in the render output, this value is - in practice - wildly overkill, but 
                it downsamples to the mipmaps very well.
              </p>
            </section>
          </dd>        
        </dl>

        <h3>Private Structures</h3>
        <dl class="member-list">
          <dt id="AspectData">AspectData</dt>
          <dd>
            <h5>Description</h5>
            <section>
              Information generated by <code><a href="#CalculateAspectData">CalculateAspectData</a></code> with some
              commonly-calculated aspect-related values.
            </section>
            <h5>Fields</h5>
            <section>
              <dl>
                <dt><code>overscanSize</code></dt>
                <dd>
                  <p>Type: <code><A href="../structs/vec2.html">Vec2</a></code></p>
                  <p>
                    This contains (as an x, y vector) the width and height of the original (pre-generation/decode) image (the original 
                    source RGB image), minus the amount of overscan specified by <code><a href="#overscanSettings">overscanSettings</a></code>.
                  </p>
                </dd>
                <dt><code>aspect</code></dt>
                <dd>
                  <p>Type: <code>float</code></p>
                  <p>
                    This value represents the actual aspect ratio (width / height) of the screen, taking into account both the above 
                    <code>overscanSize</code> value and <code><a href="#pixelAspect">pixelAspect</a></code>.
                  </p>
                </dd>
              </dl>
            </section>
          </dd>

          <dt id="CommonConstants">CommonConstants</dt>
          <dd>
            <h5>Description</h5>
            <section>
              <p>
                This contains the initial values for both <code><a href="#ScreenTextureConstants">ScreenTextureConstants</a></code>
                and <code><a href="#RGBToScreenConstants">RGBToScreenConstants</a></code>.
              </p>
              <p>
                These values correspond to the initial four input constant values in the <a href="../../shader-reference/crt-shaders/generate-screen-texture.html">crt-generate-screen-texture</a>
                and <a href="../../shader-reference/crt-shaders/rgb-to-crt.html">crt-rgb-to-crt</a> shaders. Refer to those pages for documentation of the fields.
              </p>
            </section>
          </dd>


          <dt id="ScreenTextureConstants">ScreenTextureConstants</dt>
          <dd>
            <h5>Description</h5>
            <section>
              This structure maps to the constant buffer input to the <a href="../../shader-reference/crt-shaders/generate-screen-texture.html">crt-generate-screen-texture</a>
              shader. Refer to its page for documentation of the fields.
            </section>
          </dd>

          <dt id="RGBToScreenConstants">RGBToScreenConstants</dt>
          <dd>
            <h5>Description</h5>
            <section>
              This structure maps to the constant buffer input to the <a href="../../shader-reference/crt-shaders/rgb-to-crt.html">crt-rgb-to-crt</a>
              shader. Refer to its page for documentation of the fields.
            </section>
          </dd>

          <dt id="GaussianBlurConstants">GaussianBlurConstants</dt>
          <dd>
            <h5>Description</h5>
            <section>
              This structure maps to the constant buffer input to the <a href="../../shader-reference/util-shaders/gaussian-blur.html">util-gaussian-blur</a>
              shader. Refer to its page for documentation of the fields.
            </section>
          </dd>

          <dt id="ToneMapConstants">ToneMapConstants</dt>
          <dd>
            <h5>Description</h5>
            <section>
              This structure maps to the constant buffer input to the <a href="../../shader-reference/util-shaders/tonemap-and-downsample.html">util-tonemap-and-downsample</a>
              shader. Refer to its page for documentation of the fields.
            </section>
          </dd>
        </dl>

        <h3>Private Methods</h3>
        <dl class="member-list">
          <dt id="CalculateAspectData">CalculateAspectData</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                AspectData CalculateAspectData()
              </pre>
            </div>
            <h5>Description</h5>
            <section>
              <p>
                Calculates the dimensions of the original (pre-generation/decode) input texture would have
                after overscan is applied, as well as the aspect ratio of the full image. 
              </p>
              <p>
                Called by
                <code><a href="#CalculateCommonConstants">CalculateCommonConstants</a></code>,
                <code><a href="#RenderScreenTexture">RenderScreenTexture</a></code>,
                and <code><a href="#UpdateBlurTextures">UpdateBlurTextures</a></code>.
              </p>
            </section>
            <h5>Return Value</h5>
            <section>
              Type: <code><a href="#AspectData">RGBToCRT::<wbr>AspectData</a></code></p>
              <p>
                The calculated data.
              </p>
            </section>
          </dd>        

          <dt id="CalculateCommonConstants">CalculateCommonConstants</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                CommonConstants CalculateCommonConstants(
                  const AspectData &amp;aspectData)
              </pre>
            </div>
            <h5>Description</h5>
            <section>
              <p>
                Calculate some values that are common to both 
                <code><a href="#ScreenTextureConstants">RGBToCRT::<wbr>ScreenTextureConstants</a></code>
                and 
                <code><a href="#RGBToScreenConstants">RGBToCRT::<wbr>RGBToScreenConstants</a></code>.
              </p>
              <p>
                Called by
                <code><a href="#Render">Render</a></code>
                and <code><a href="#RenderScreenTexture">RenderScreenTexture</a></code>.
              </p>
            </section>
            <h5>Parameters</h5>
            <section>
              <dl>
                <dt><code>aspectData</code></dt>
                <dd>
                  <p>Type: <code>const <a href="#AspectData">RGBToCRT::<wbr>AspectData</a> &amp;</code></p>
                  <p>
                    The output of a call to <code><a href="#CalculateAspectData">CalculateAspectData</a></code>.
                  </p>
                </dd>
              </dl>
            </section>
            <h5>Return Value</h5>
            <section>
              <p>Type: <code><a href="#CommonConstants">RGBToCRT::<wbr>CommonConstants</a></code></p>
              <p>
                The calculated constants.
              </p>
            </section>
          </dd>        

          <dt id="RenderScreenTexture">RenderScreenTexture</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                void RenderScreenTexture()
              </pre>
            </div>
            <h5>Description</h5>
            <section>
              <p>
                Renders to <code><a href="#screenTexture">screenTexture</a></code>, which contains an image that 
                has the CRT mask (with proper curvature applied) in the RGB channels and a mask of what is or is not
                visible on the screen in the alpha channel.
              </p>
              <p>
                It's worth noting that the shader that renders this does a very expensive 64-tap sample of the mask
                texture to alleviate <a href="https://en.wikipedia.org/wiki/Aliasing" target="_blank">aliasing</a>,
                so the <code>RGBToCRT</code> does a fair amount of work to only do this when necessary (after a call to
                <code><a href="#SetSettings">SetSettings</a></code> or <code><a href="#SetOutputSize">SetOutputSize</a></code>
                in which the values were changed).
              </p>
              <p>
                Called by <code><a href="#Render">Render</a></code>.
              </p>
            </section>
          </dd>        

          <dt id="UpdateBlurTextures">UpdateBlurTextures</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                void UpdateBlurTextures()
              </pre>
            </div>
            <h5>Description</h5>
              <p>
                Calculates the required sizes for 
                <code><a href="#toneMapTexture">toneMapTexture</a></code>,
                <code><a href="#blurTexture">blurTexture</a></code>,
                and <code><a href="#blurScratchTexture">blurScratchTexture</a></code>.
                Then, if the sizes are different from the existing versions of those textures,
                will create new textures at the proper size.
              </p>
              <p>
                Called by <a href="#constructor">the constructor</a> and <code><a href="#SetSettings">SetSettings</a></code>.
              </p>
            <section>
            </section>
          </dd>        

          <dt id="RenderMaskTexture">RenderMaskTexture</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                void RenderMaskTexture()
              </pre>
            </div>
            <h5>Description</h5>
            <section>
              <p>
                Renders a mask to <code><a href="#maskTexture">maskTexture</a></code>, given the 
                <code><a href="../enums/masktype.html">MaskType</a></code> value
                stored in <code><a href="#screenSettings">screenSettings</a></code>.
              </p>
              <p>
                This uses a lanczos downsample pass to generate the <a href="https://en.wikipedia.org/wiki/Mipmap" target="_blank">mipmap</a> levels.
              </p>
              <p>
                This is only called after a call to
                <code><a href="#SetSettings">SetSettings</a></code> or <code><a href="#SetOutputSize">SetOutputSize</a></code>
                in which the values were changed.
              </p>
              <p>
                Called by <code><a href="#Render">Render</a></code>.
              </p>
            </section>
          </dd>        

          <dt id="RenderBlur">RenderBlur</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                void RenderBlur(
                  const ITexture *inputTexture)
              </pre>
            </div>
            <h5>Description</h5>
            <section>
              <p>
                Does a tonemap and blur of the given input texture, which is used as an approximation of CRT diffusion
                (the scattering of photons as they pass through the glass front of the CRT screen).
              </p>
              <p>
                Called by <code><a href="#Render">Render</a></code>.
              </p>
            </section>
            <h5>Parameters</h5>
            <section>
              <dl>
                <dt><code>inputTexture</code></dt>
                <dd>
                  <p>Type: <code>const <a href="../interfaces/itexture.html">ITexture</a> *</code></p>
                  <p>
                    The texture to tonemap and then blur.
                  </p>
                </dd>
              </dl>
            </section>
          </dd>        
        </dl>

        <h3>Private Fields</h3>
        <dl class="member-list">
          <dt id="device">device</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                IGraphicsDevice *device
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code><a href="../interfaces/igraphicsdevice.html">IGraphicsDevice</a> *</code>
            </section>
            <h5>Description</h5>
            <section>
              Pointer to the graphics device that should be used to create graphics objects and render.
            </section>
          </dd>



          <dt id="originalInputImageWidth">originalInputImageWidth</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                uint32_t originalInputImageWidth
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>uint32_t</code>
            </section>
            <h5>Description</h5>
            <section>
              The width of the original image (before the generator/decoder process).
            </section>
          </dd>

          <dt id="processedRGBTextureWidth">processedRGBTextureWidth</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                uint32_t processedRGBTextureWidth
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>uint32_t</code>
            </section>
            <h5>Description</h5>
            <section>
              <p>
                The expected width of the texture that will be passed in to <code><a href="#Render">Render</a></code>.
              </p>
              <p>
                If no generator/decoder process is being used (i.e. if the <code><a href="cathoderetro.html">CathodeRetro</a></code> class 
                is being used in <a href="../enums/signaltype.html#RGB">RGB mode</a>, this will be the same value as 
                <code><a href="#originalInputImageWidth">originalInputImageWidth</a></code>.
              </p>
            </section>
          </dd>

          <dt id="scanlineCount">scanlineCount</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                uint32_t scanlineCount
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>uint32_t</code>
            </section>
            <h5>Description</h5>
            <section>
              <p>
                The number of scanlines per input image (i.e. the height of the input texture).
              </p>
            </section>
          </dd>

          <dt id="pixelAspect">pixelAspect</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                float pixelAspect
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>float</code>
            </section>
            <h5>Description</h5>
            <section>
              <p>
                The aspect ratio (width/height) of an input pixel (pre-generator/decoder) on the screen.
                This allows for emulation of non-square-pixel video modes.
              </p>
              <p>
                For example: 
                <ul>
                  <li>On the NES, pixels were slightly stretched horizontally and have an 8:7 (8/7) aspect ratio.</li>
                  <li>
                    Old <a href="https://en.wikipedia.org/wiki/Mode_13h" target="_blank">mode 13h</a> 
                    modes had slightly tall pixels on 4x3 monitors, resulting in pixels that are 5:6.
                  </li>
                </ul>
              </p>
            </section>
          </dd>

          <dt id="isFirstFrame">isFirstFrame</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                bool isFirstFrame = true
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>bool</code>
            </section>
            <h5>Description</h5>
            <section>
              <p>
                This is true before <code><a href="#Render">Render</a></code> is called the first time,
                and false afterward.
              </p>
              <p>
                Because this class keeps a copy of the previous frame (in <code><a href="#prevRGBInput">prevRGBInput</a></code>)
                and uses that to handle phosphor persistence, on the very first call to <code>Render</code> this flag is used 
                to initialize <code>prevRGBInput</code> so that it can be used.
              </p>
            </section>
          </dd>



          <dt id="screenTextureConstantBuffer">screenTextureConstantBuffer</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                std::unique_ptr&lt;IConstantBuffer&gt; screenTextureConstantBuffer
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>std::unique_ptr&lt;<a href="../interfaces/iconstantbuffer.html">IConstantBuffer</a>&gt;</code>
            </section>
            <h5>Description</h5>
            <section>
              The constant buffer that is used in <code><a href="#RenderScreenTexture">RenderScreenTexture</a></code> as an input to the 
              <a href="../../shader-reference/crt-shaders/generate-screen-texture.html">crt-generate-screen-texture</a>
              shader.
            </section>
          </dd>

          <dt id="rgbToScreenConstantBuffer">rgbToScreenConstantBuffer</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                std::unique_ptr&lt;IConstantBuffer&gt; rgbToScreenConstantBuffer
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>std::unique_ptr&lt;<a href="../interfaces/iconstantbuffer.html">IConstantBuffer</a>&gt;</code>
            </section>
            <h5>Description</h5>
            <section>
              The constant buffer that is used in <code><a href="#Render">Render</a></code> as an input to the 
              <a href="../../shader-reference/crt-shaders/rgb-to-crt.html">crt-rgb-to-crt</a>
              shader.
            </section>
          </dd>

          <dt id="toneMapConstantBuffer">toneMapConstantBuffer</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                std::unique_ptr&lt;IConstantBuffer&gt; toneMapConstantBuffer
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>std::unique_ptr&lt;<a href="../interfaces/iconstantbuffer.html">IConstantBuffer</a>&gt;</code>
            </section>
            <h5>Description</h5>
            <section>
              The constant buffer that is used in <code><a href="#RenderBlur">RenderBlur</a></code> as an input to the 
              <a href="../../shader-reference/util-shaders/tonemap-and-downsample.html">util-tonemap-and-downsample</a>
              shader.
            </section>
          </dd>

          <dt id="blurDownsampleConstantBuffer">blurDownsampleConstantBuffer</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                std::unique_ptr&lt;IConstantBuffer&gt; blurDownsampleConstantBuffer
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>std::unique_ptr&lt;<a href="../interfaces/iconstantbuffer.html">IConstantBuffer</a>&gt;</code>
            </section>
            <h5>Description</h5>
            <section>
              The constant buffer that is used in <code><a href="#RenderBlur">RenderBlur</a></code> as an input to the 
              <a href="../../shader-reference/util-shaders/downsample-2x.html">util-downsample-2x</a>
              shader, to do a horizontal downsample before the blurring.
            </section>
          </dd>

          <dt id="gaussianBlurConstantBufferH">gaussianBlurConstantBufferH</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                std::unique_ptr&lt;IConstantBuffer&gt; gaussianBlurConstantBufferH
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>std::unique_ptr&lt;<a href="../interfaces/iconstantbuffer.html">IConstantBuffer</a>&gt;</code>
            </section>
            <h5>Description</h5>
            <section>
              The constant buffer that is used in <code><a href="#RenderBlur">RenderBlur</a></code> as an input to the 
              <a href="../../shader-reference/util-shaders/gaussian-blur.html">util-gaussian-blur</a>
              shader, to do the horizontal blur pass.
            </section>
          </dd>

          <dt id="gaussianBlurConstantBufferV">gaussianBlurConstantBufferV</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                std::unique_ptr&lt;IConstantBuffer&gt; gaussianBlurConstantBufferV
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>std::unique_ptr&lt;<a href="../interfaces/iconstantbuffer.html">IConstantBuffer</a>&gt;</code>
            </section>
            <h5>Description</h5>
              The constant buffer that is used in <code><a href="#RenderBlur">RenderBlur</a></code> as an input to the 
              <a href="../../shader-reference/util-shaders/gaussian-blur.html">util-gaussian-blur</a>
              shader, to do the vertical blur pass.
            <section>
            </section>
          </dd>

          <dt id="generateMaskConstantBuffer">generateMaskConstantBuffer</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                std::unique_ptr&lt;IConstantBuffer&gt; generateMaskConstantBuffer
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>std::unique_ptr&lt;<a href="../interfaces/iconstantbuffer.html">IConstantBuffer</a>&gt;</code>
            </section>
            <h5>Description</h5>
            <section>
              The constant buffer that is used in <code><a href="#RenderMaskTexture">RenderMaskTexture</a></code> 
              as an input to one of the
              <a href="../../shader-reference/crt-shaders/generate-shadow-mask.html">crt-generate-shadow-mask</a>,
              <a href="../../shader-reference/crt-shaders/generate-slot-mask.html">crt-generate-slot-mask</a>,
              or <a href="../../shader-reference/crt-shaders/generate-aperture-grille.html">crt-generate-aperture-grille</a>
              shaders (depending on the value of <code><a href="#screenSettings">screenSettings</a>.<a href="../structs/screensettings.html#maskType">maskType</a></code>) 
              to generate the largest mip level of <code><a href="#maskTexture">maskTexture</a></code>.
            </section>
          </dd>

          <dt id="maskDownsampleConstantBufferH">maskDownsampleConstantBufferH</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                std::unique_ptr&lt;IConstantBuffer&gt; maskDownsampleConstantBufferH
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>std::unique_ptr&lt;<a href="../interfaces/iconstantbuffer.html">IConstantBuffer</a>&gt;</code>
            </section>
            <h5>Description</h5>
            <section>
              The constant buffer that is used in <code><a href="#RenderMaskTexture">RenderMaskTexture</a></code> 
              as an input to the <a href="../../shader-reference/util-shaders/downsample-2x.html">util-downsample-2x</a>
              shader to do the horizontal downsample into a scratch texture (<code><a href="#halfWidthMaskTexture">halfWidthMaskTexture</a></code>)
              during the generation of the mipmaps of <code><a href="#maskTexture">maskTexture</a></code>.
            </section>
          </dd>

          <dt id="maskDownsampleConstantBufferV">maskDownsampleConstantBufferV</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                std::unique_ptr&lt;IConstantBuffer&gt; maskDownsampleConstantBufferV
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>std::unique_ptr&lt;<a href="../interfaces/iconstantbuffer.html">IConstantBuffer</a>&gt;</code>
            </section>
            <h5>Description</h5>
            <section>
              The constant buffer that is used in <code><a href="#RenderMaskTexture">RenderMaskTexture</a></code> 
              as an input to the <a href="../../shader-reference/util-shaders/downsample-2x.html">util-downsample-2x</a>
              shader to do the vertical downsample from the scratch texture (<code><a href="#halfWidthMaskTexture">halfWidthMaskTexture</a></code>),
              during the generation of the mipmaps of <code><a href="#maskTexture">maskTexture</a></code>.
            </section>
          </dd>



          <dt id="prevRGBInput">prevRGBInput</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                std::unique_ptr&lt;IRenderTarget&gt; prevRGBInput
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>std::unique_ptr&lt;<a href="../interfaces/irendertarget.html">IRenderTarget</a>&gt;</code>
            </section>
            <h5>Description</h5>
            <section>
              This texture is a copy of the <code>currentFrameRGBInput</code> parameter that was passed to the previous call
              to <code><a href="#Render">Render</a></code>, and is used to emulate phosphor persistence (where a little of the previous frame
              is still visible).
            </section>
          </dd>



          <dt id="maskTexture">maskTexture</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                std::unique_ptr&lt;IRenderTarget&gt; maskTexture
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>std::unique_ptr&lt;<a href="../interfaces/irendertarget.html">IRenderTarget</a>&gt;</code>
            </section>
            <h5>Description</h5>
            <section>
              This is a mipmapped texture, which holds the CRT mask texture that we use to generate the screen texture.
              It is generated by <code><a href="#RenderMaskTexture">RenderMaskTexture</a></code> whenever 
              the value of value of <code><a href="#screenSettings">screenSettings</a>.<a href="../structs/screensettings.html#maskType">maskType</a></code>
              changes.
            </section>
          </dd>

          <dt id="halfWidthMaskTexture">halfWidthMaskTexture</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                std::unique_ptr&lt;IRenderTarget&gt; halfWidthMaskTexture
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>std::unique_ptr&lt;<a href="../interfaces/irendertarget.html">IRenderTarget</a>&gt;</code>
            </section>
            <h5>Description</h5>
            <section>
              This is an intermediate texture used during the generation of mipmap levels in <code><a href="#RenderMaskTexture">RenderMaskTexture</a></code>.
              It has the same height as <code><a href="#maskTexture">maskTexture</a></code> but has half the width, and is used as
              the target for the horizontal pass of the downsample.
            </section>
          </dd>

          <dt id="screenTexture">screenTexture</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                std::unique_ptr&lt;IRenderTarget&gt; screenTexture
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>std::unique_ptr&lt;<a href="../interfaces/irendertarget.html">IRenderTarget</a>&gt;</code>
            </section>
            <h5>Description</h5>
            <section>
              This texture has an image that has the CRT mask (with proper curvature applied) in the RGB channels and a 
              mask of what is or is not visible on the screen in the alpha channel. It is generated by
              <code><a href="#RenderScreenTexture">RenderScreenTexture</a></code>. It has the same width and height as
              the final output texture of the <code><a href="#Render">Render</a></code> method.
            </section>
          </dd>



          <dt id="toneMapTexture">toneMapTexture</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                std::unique_ptr&lt;IRenderTarget&gt; toneMapTexture
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>std::unique_ptr&lt;<a href="../interfaces/irendertarget.html">IRenderTarget</a>&gt;</code>
            </section>
            <h5>Description</h5>
            <section>
              This texture is the target of the first pass of <code><a href="#RenderBlur">RenderBlur</a></code>,
              which does the tonemapping (and also a resize to get closer to the desired blur resolution).
            </section>
          </dd>

          <dt id="blurScratchTexture">blurScratchTexture</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                std::unique_ptr&lt;IRenderTarget&gt; blurScratchTexture
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>std::unique_ptr&lt;<a href="../interfaces/irendertarget.html">IRenderTarget</a>&gt;</code>
            </section>
            <h5>Description</h5>
            <section>
              This texture is the target of the second and fourth passes of <code><a href="#RenderBlur">RenderBlur</a></code>
              (and is the ultimate result of that method), and ultimately contains the blurred version of the input texture
              that is used to emulate CRT diffusion (the scattering of photons as they pass through the glass front of the CRT screen).
            </section>
          </dd>

          <dt id="blurTexture">blurTexture</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                std::unique_ptr&lt;IRenderTarget&gt; blurTexture
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>std::unique_ptr&lt;<a href="../interfaces/irendertarget.html">IRenderTarget</a>&gt;</code>
            </section>
            <h5>Description</h5>
            <section>
              This texture is the target of the third pass of <code><a href="#RenderBlur">RenderBlur</a></code>,
              which is the horizontal gaussian blur pass. It is then used in the final pass to do the vertical blur
              to get the final result.
            </section>
          </dd>



          <dt id="screenSettings">screenSettings</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                ScreenSettings screenSettings
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code><a href="../structs/screensettings.html">ScreenSettings</a></code>
            </section>
            <h5>Description</h5>
            <section>
              The screen settings that were applied by <code><a href="#SetSettings">SetSettings</a></code>.
            </section>
          </dd>

          <dt id="overscanSettings">overscanSettings</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                OverscanSettings overscanSettings
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code><a href="../structs/overscansettings.html">OverscanSettings</a></code>
            </section>
            <h5>Description</h5>
            <section>
              The overscan settings that were applied by <code><a href="#SetSettings">SetSettings</a></code>.
            </section>
          </dd>

          <dt id="needsRenderScreenTexture">needsRenderScreenTexture</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                bool needsRenderScreenTexture = false
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>bool</code>
            </section>
            <h5>Description</h5>
            <section>
              This value is set to true by <code><a href="#SetSettings">SetSettings</a></code>
              or <code><a href="#SetSettings">SetOutputSize</a></code> when there is a change to
              the way the screen texture appears (including a change to the output resolution), 
              so that <code><a href="#Render">Render</a></code> will
              call <code><a href="#RenderScreenTexture">RenderScreenTexture</a></code>.
            </section>
          </dd>

          <dt id="needsRenderMaskTexture">needsRenderMaskTexture</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                bool needsRenderMaskTexture = false
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>bool</code>
            </section>
            <h5>Description</h5>
            <section>
              This value is set to true by <code><a href="#SetSettings">SetSettings</a></code> when
              the value of <code><a href="#screenSettings">screenSettings</a>.<a href="../structs/screensettings.html#maskType">maskType</a></code>
              changes, so that <code><a href="#Render">Render</a></code> will
              call <code><a href="#RenderMaskTexture">RenderMaskTexture</a></code>.
            </section>
          </dd>



          <dt id="prevScanlineType">prevScanlineType</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                ScanlineType prevScanlineType 
                  = ScanlineType::Progressive
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code><a href="../enums/scanlinetype.html">ScanlineType</a></code>
            </section>
            <h5>Description</h5>
            <section>
              The scanline type from the previous call to <code><a href="#Render">Render</a></code>.
              This is used by <code>Render</code> to ensure that the scanlines from the previous frame are
              rendered with the correct even/odd parity to handle both progressive and interlacing modes
              when phosphor persistence emulation is enabled.
            </section>
          </dd>

          <dt id="downsampleDirX">downsampleDirX</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                float downsampleDirX
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>float</code>
            </section>
            <h5>Description</h5>
            <section>
              The x component of the direction of the downsample during the tonemap pass in 
              <code><a href="#RenderBlur">RenderBlur</a></code>. This and <code><a href="#downsampleDirY">downsampleDirY</a></code>
              are set to do either a horizontal or vertical blur depending on which blur gets us closer to the desired
              aspect ratio for the final blurred texture.
            </section>
          </dd>

          <dt id="downsampleDirY">downsampleDirY</dt>
          <dd>
            <div class="code-definition syntax-cpp">
              <pre>
                float downsampleDirY
              </pre>
            </div>
            <h5>Type</h5>
            <section>
              <code>float</code>
            </section>
            <h5>Description</h5>
            <section>
              The y component of the direction of the downsample during the tonemap pass in 
              <code><a href="#RenderBlur">RenderBlur</a></code>. This and <code><a href="#downsampleDirX">downsampleDirX</a></code>
              are set to do either a horizontal or vertical blur depending on which blur gets us closer to the desired
              aspect ratio for the final blurred texture.
            </section>
          </dd>
        </dl>
      </main>
    </div>
  </body>
</html>